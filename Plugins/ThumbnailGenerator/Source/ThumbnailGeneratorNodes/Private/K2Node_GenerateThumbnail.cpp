// Mans Isaksson 2020

#include "K2Node_GenerateThumbnail.h"
#include "K2Node_CustomEvent.h"
#include "K2Node_CallFunction.h"
#include "K2Node_MakeMap.h"
#include "K2Node_DynamicCast.h"
#include "KismetCompiler.h"
#include "BlueprintNodeSpawner.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintCompilationManager.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "ThumbnailGenerator.h"

#define LOCTEXT_NAMESPACE "K2Node_GenerateThumbnail"

namespace
{
	const FName ClassPinName                 = "ActorClass";
	const FName ThumbnailSettingsPinName     = "ThumbnailSettings";
	const FName CacheMethodPinName           = "CacheMethod";
	const FName CallbackPinName              = "Callback";
	const FName ThumbnailOutputPinName       = "Thumbnail";
	const FName PreCapturePinName            = "PreCaptureThumbnail";
	const FName PreCaptureActorOutputPinName = "PreCaptureActorOutput";
}

UK2Node_GenerateThumbnail::UK2Node_GenerateThumbnail()
{
	AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
}

void UK2Node_GenerateThumbnail::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	// Exec Input/Output
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	// Add In Actor Class Pin
	UEdGraphPin* ActorClassPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Class, AActor::StaticClass(), ClassPinName);
	ActorClassPin->PinFriendlyName = LOCTEXT("ActorClass_Name", "Actor Class");
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(ActorClassPin);
	SetPinToolTip(*ActorClassPin, LOCTEXT("ActorClassPin_Description", "The actor class of which a thumbnail will be generated."));

	// Add In Thumbnail Settings pin
	UEdGraphPin* ThumbnailSettingsPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, FThumbnailSettings::StaticStruct(), ThumbnailSettingsPinName);
	ThumbnailSettingsPin->PinFriendlyName = LOCTEXT("ThumbnailSettingsPin_Name", "Thumbnail Settings");
	SetPinToolTip(*ThumbnailSettingsPin, LOCTEXT("ThumbnailSettingsPin_Description", "This struct can be used to override individual Thumbnail Settings for this capture."));

	// Add In Cache Method pin
	UEdGraphPin* CacheMethodPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Byte, StaticEnum<ECacheMethod>(), CacheMethodPinName);
	CacheMethodPin->PinFriendlyName = LOCTEXT("CacheMethodPin_Name", "Cache Method");
	CacheMethodPin->bAdvancedView   = true;
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(CacheMethodPin);
	SetPinToolTip(*CacheMethodPin, LOCTEXT("CacheMethodPin_Description", "How, or if, to use the cache."));

	// Add Callback Out Exec Pin
	UEdGraphPin* CallbackPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, CallbackPinName);
	CallbackPin->PinFriendlyName = LOCTEXT("CallbackPin_Name", "Callback");
	SetPinToolTip(*CallbackPin, LOCTEXT("CallbackPin_Description", "Executed once the thumbnail has been generated."));

	// Add Thumbnail Output Pin
	UEdGraphPin* ThumbnailOutputPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Object, UTexture2D::StaticClass(), ThumbnailOutputPinName);
	ThumbnailOutputPin->PinFriendlyName = LOCTEXT("ThumbnailOutputPin_Name", "Thumbnail");
	SetPinToolTip(*ThumbnailOutputPin, LOCTEXT("ThumbnailOutputPin_Description", "The generated UTexture2D object (null if thumbnail failed to generate)"));

	// Add PreCapture Out Exec Pin
	UEdGraphPin* PreCapturePin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PreCapturePinName);
	PreCapturePin->PinFriendlyName = LOCTEXT("PreCapturePin_Name", "Pre Capture");
	PreCapturePin->bAdvancedView   = true;
	SetPinToolTip(*PreCapturePin, LOCTEXT("PreCapturePin_Description", "Right before the thumbnail is captured of the actor."));

	// Add PreCaptureActor Output Pin
	UEdGraphPin* PreCaptureActorOutputPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Object, AActor::StaticClass(), PreCaptureActorOutputPinName);
	PreCaptureActorOutputPin->PinFriendlyName = LOCTEXT("PreCaptureActorOutputPin_Name", "Actor");
	PreCaptureActorOutputPin->bAdvancedView   = true;
	SetPinToolTip(*PreCaptureActorOutputPin, LOCTEXT("PreCaptureActorOutputPin_Description", "Reference to the actor for which the thumbnail is being generated"));

	Super::AllocateDefaultPins();
}

bool UK2Node_GenerateThumbnail::IsCompatibleWithGraph(const UEdGraph* TargetGraph) const
{
	// Can only place events in ubergraphs and macros (other code will help prevent macros with latents from ending up in functions)
	const EGraphType GraphType = TargetGraph->GetSchema()->GetGraphType(TargetGraph);
	return (GraphType == EGraphType::GT_Ubergraph || GraphType == EGraphType::GT_Macro) && Super::IsCompatibleWithGraph(TargetGraph);
}

void UK2Node_GenerateThumbnail::PinDefaultValueChanged(UEdGraphPin* ChangedPin) 
{
	if (ChangedPin && (ChangedPin->PinName == ClassPinName))
	{
		OnClassPinChanged();
	}
}

void UK2Node_GenerateThumbnail::PinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::PinConnectionListChanged(Pin);

	if (Pin && (Pin->PinName == ClassPinName))
	{
		OnClassPinChanged();
	}
}


FText UK2Node_GenerateThumbnail::GetTooltipText() const
{
	return FText::FromString(TEXT("Generates a thumbnail for the selected actor class"));
}

void UK2Node_GenerateThumbnail::PostPlacedNewNode()
{
	Super::PostPlacedNewNode();

	if (UClass* UseSpawnClass = GetClassToSpawn())
	{
		CreatePinsForClass(UseSpawnClass);
	}
}

void UK2Node_GenerateThumbnail::ReallocatePinsDuringReconstruction(TArray<UEdGraphPin*>& OldPins) 
{
	AllocateDefaultPins();
	if (UClass* UseSpawnClass = GetClassToSpawn(&OldPins))
	{
		CreatePinsForClass(UseSpawnClass);
	}
	RestoreSplitPins(OldPins);
}

FText UK2Node_GenerateThumbnail::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	if (TitleType == ENodeTitleType::ListView || TitleType == ENodeTitleType::MenuTitle)
	{
		return LOCTEXT("GenerateThumbnail_BaseTitle", "Generate Thumbnail");
	}
	else if (UClass* ClassToSpawn = GetClassToSpawn())
	{
		if (CachedNodeTitle.IsOutOfDate(this))
		{
			FFormatNamedArguments Args;
			Args.Add(TEXT("ClassName"), ClassToSpawn->GetDisplayNameText());
			CachedNodeTitle.SetCachedText(FText::Format(LOCTEXT("GenerateThumbnail", "Generate {ClassName} Thumbnail"), Args), this);
		}
		return CachedNodeTitle;
	}
	return LOCTEXT("GenerateThumbnail_Title_NONE", "Generate Thumbnail");
}

void UK2Node_GenerateThumbnail::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();
	check(Schema);
	bool bIsErrorFree = true;

	UEdGraphPin* const OriginalClassInPin             = GetClassPin();
	UEdGraphPin* const OriginalCacheMethodInPin       = GetCacheMethodPin();
	UEdGraphPin* const OriginalThumbnailSettingsInPin = GetThumbnailSettingsPin();
	UEdGraphPin* const OriginalClassPin               = GetClassPin();

	UClass* SpawnClass = (OriginalClassPin != nullptr) ? Cast<UClass>(OriginalClassPin->DefaultObject) : nullptr;
	if (!OriginalClassPin || (OriginalClassPin->LinkedTo.Num() == 0 && SpawnClass == nullptr))
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("GenerateThumbnail_Error", "Generate Thumbnail node @@ must have a @@ specified.").ToString(), this, OriginalClassPin);
		// we break exec links so this is the only error we get, don't want the SpawnActor node being considered and giving 'unexpected node' type warnings
		BreakAllNodeLinks();
		return;
	}

	// FUNCTION NODE
	const FName FunctionName = GET_FUNCTION_NAME_CHECKED(UThumbnailGeneration, K2_GenerateThumbnail);
	UK2Node_CallFunction* const GenerateThumbnailFunctionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

	// Connect user function inputs
	{
		GenerateThumbnailFunctionNode->FunctionReference.SetExternalMember(FunctionName, UThumbnailGeneration::StaticClass());
		GenerateThumbnailFunctionNode->AllocateDefaultPins();

		UEdGraphPin* const FunctionNodeExecPin            = GenerateThumbnailFunctionNode->GetExecPin();
		UEdGraphPin* const FunctionNodeThenPin            = GenerateThumbnailFunctionNode->GetThenPin();
		UEdGraphPin* const FunctionClassInPin             = GenerateThumbnailFunctionNode->FindPinChecked(ClassPinName);
		UEdGraphPin* const FunctionThumbnailSettingsInPin = GenerateThumbnailFunctionNode->FindPinChecked(ThumbnailSettingsPinName);
		UEdGraphPin* const FunctionCacheMethodInPin       = GenerateThumbnailFunctionNode->FindPinChecked(CacheMethodPinName);

		// Connect Original Exec pin to function Exec input
		bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*GetExecPin(), *FunctionNodeExecPin).CanSafeConnect();

		// Connect Original Then pin to function Then input
		bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*GetThenPin(), *FunctionNodeThenPin).CanSafeConnect();

		// Connect Original Class input to function Class input
		bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*OriginalClassInPin, *FunctionClassInPin).CanSafeConnect();

		// Connect Original Cache Method input to function Cache Method input
		bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*OriginalCacheMethodInPin, *FunctionCacheMethodInPin).CanSafeConnect();

		// Connect Original ThumbnailSettings input to function ThumbnailSettings input
		bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*OriginalThumbnailSettingsInPin, *FunctionThumbnailSettingsInPin).CanSafeConnect();
	}

	// Uses K2Node_LoadAsset as reference, look into that function for a more generic approach
	const auto ExpandCallbackEvent = [&](const FName& FunctionDelegateInputPinName, const FName& CallbackEventParamPinName, 
		const FName& NodeOutExecPinName, const FName& NodeOutValuePinName)
	{
		UEdGraphPin* DelegatePropertyPin     = GenerateThumbnailFunctionNode->FindPinChecked(FunctionDelegateInputPinName);
		UK2Node_CustomEvent* CustomEventNode = CompilerContext.SpawnIntermediateEventNode<UK2Node_CustomEvent>(this, DelegatePropertyPin, SourceGraph);
		CustomEventNode->CustomFunctionName  = *FString::Printf(TEXT("%s_%s"), *FunctionDelegateInputPinName.ToString(), *CompilerContext.GetGuid(this));
		
		CustomEventNode->AllocateDefaultPins();
		{
			UFunction* InlineSerializeFunction          = GenerateThumbnailFunctionNode->GetTargetFunction();
			FDelegateProperty* FunctionDelegateProperty = InlineSerializeFunction ? FindFProperty<FDelegateProperty>(InlineSerializeFunction, FunctionDelegateInputPinName) : nullptr;
			UFunction* FunctionDelegateSignature        = FunctionDelegateProperty ? FunctionDelegateProperty->SignatureFunction : nullptr;
			
			ensure(FunctionDelegateSignature);
			
			if (FunctionDelegateSignature && CallbackEventParamPinName != NAME_None && NodeOutValuePinName != NAME_None)
			{
				const FProperty* Param = FunctionDelegateSignature->FindPropertyByName(CallbackEventParamPinName);
				
				ensure(Param && !(Param->HasAnyPropertyFlags(CPF_OutParm) && !Param->HasAnyPropertyFlags(CPF_ReferenceParm)) && !Param->HasAnyPropertyFlags(CPF_ReturnParm));
				
				FEdGraphPinType PinType;
				bIsErrorFree &= Schema->ConvertPropertyToPinType(Param, PinType);
				bIsErrorFree &= (nullptr != CustomEventNode->CreateUserDefinedPin(Param->GetFName(), PinType, EGPD_Output));
			}
		}

		// Connect Custom Event Delegate Pin to Function Delegate Input
		{
			UEdGraphPin* CustomEventDelegatePin = CustomEventNode->FindPinChecked(UK2Node_CustomEvent::DelegateOutputName);
			bIsErrorFree &= Schema->TryCreateConnection(DelegatePropertyPin, CustomEventDelegatePin);
		}

		// Connect Custom Event output to main node value output
		if (CallbackEventParamPinName != NAME_None && NodeOutValuePinName != NAME_None)
		{
			UEdGraphPin* CustomEventParamPin = CustomEventNode->FindPinChecked(CallbackEventParamPinName);
			UEdGraphPin* NodeOutputParamPin  = FindPinChecked(NodeOutValuePinName);

			if (NodeOutputParamPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Object
				&& NodeOutputParamPin->PinType.PinSubCategoryObject != CustomEventParamPin->PinType.PinSubCategoryObject) // Needs casting
			{
				UK2Node_DynamicCast* CastNode = CompilerContext.SpawnIntermediateNode<UK2Node_DynamicCast>(this, SourceGraph);
				CastNode->SetPurity(true);
				CastNode->TargetType = CastChecked<UClass>(NodeOutputParamPin->PinType.PinSubCategoryObject.Get());
				CastNode->AllocateDefaultPins();

				bIsErrorFree &= Schema->TryCreateConnection(CustomEventParamPin, CastNode->GetCastSourcePin());
				bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*NodeOutputParamPin, *CastNode->GetCastResultPin()).CanSafeConnect();
			}
			else
			{
				bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*NodeOutputParamPin, *CustomEventParamPin).CanSafeConnect();
			}
		}

		// Connect Custom Event exec output main node exec output
		{
			UEdGraphPin* CustomEventExecPin = CustomEventNode->FindPin(UEdGraphSchema_K2::PN_Then);
			UEdGraphPin* NodeOutputExecPin  = FindPinChecked(NodeOutExecPinName);
			bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*NodeOutputExecPin, *CustomEventExecPin).CanSafeConnect();
		}
	};

	// Callback event
	ExpandCallbackEvent(TEXT("Callback"), TEXT("Thumbnail"), CallbackPinName, ThumbnailOutputPinName);

	// PreCapture event
	ExpandCallbackEvent(TEXT("PreCaptureThumbnail"), TEXT("Actor"), PreCapturePinName, PreCaptureActorOutputPinName);

	// Hook up properties exposed on spawn
	{
		static const FName FunctionPropertiesInputName(TEXT("Properties"));
		static const FName PropertyExporterPropertyInputName(TEXT("Property"));
		static const FName PropertyExporterReturnValueName(UEdGraphSchema_K2::PN_ReturnValue);

		UClass* ClassToSpawn = GetClassToSpawn();

		const auto CheckIsValidSpawnVarPin = [&](UEdGraphPin* InPin)
		{
			const bool bHasDefaultValue = !InPin->DefaultValue.IsEmpty() || !InPin->DefaultTextValue.IsEmpty() || InPin->DefaultObject;
			if (InPin->LinkedTo.Num() > 0 || bHasDefaultValue) // Only export property value if this pin is linked to something
			{
				if (InPin->LinkedTo.Num() == 0)
				{
					FProperty* Property = FindFProperty<FProperty>(ClassToSpawn, InPin->PinName);
					if (!Property) // NULL property indicates that this pin was part of the original node, not the class we're assigning to
						return false;

					// We don't want to copy the property value unless the default value differs from the value in the CDO
					FString DefaultValueAsString;

					if (FBlueprintCompilationManager::GetDefaultValue(ClassToSpawn, Property, DefaultValueAsString))
					{
						if (Schema->DoesDefaultValueMatch(*InPin, DefaultValueAsString))
							return false;
					}
					else if (ClassToSpawn->ClassDefaultObject)
					{
						FBlueprintEditorUtils::PropertyValueToString(Property, (uint8*)ClassToSpawn->ClassDefaultObject, DefaultValueAsString);
						if (DefaultValueAsString == InPin->GetDefaultAsString())
							return false;
					}
				}

				return true;
			}

			return false;
		};

		const auto SelectPropertyExportTextFunction = [](UEdGraphPin* InPin)->FName
		{
			switch (InPin->PinType.ContainerType)
			{
			case EPinContainerType::None:
				return GET_FUNCTION_NAME_CHECKED(UThumbnailGeneration, K2_ExportPropertyText);
			case EPinContainerType::Array:
				return GET_FUNCTION_NAME_CHECKED(UThumbnailGeneration, K2_ExportArrayPropertyText);
			case EPinContainerType::Set:
				return GET_FUNCTION_NAME_CHECKED(UThumbnailGeneration, K2_ExportSetPropertyText);
			case EPinContainerType::Map:
				return GET_FUNCTION_NAME_CHECKED(UThumbnailGeneration, K2_ExportMapPropertyText);
			default:
				checkf(0, TEXT("Pin Type Export Function not defined"));
			}

			return NAME_None;
		};

		const auto GetMakeMapIndexNames = [](int32 PinIndex)->TPair<FName, FName>
		{
			// Look at UK2Node_MakeMap::GetPinName for reference
			const int32 KeyIndex   = PinIndex;
			const int32 ValueIndex = ((PinIndex * 2) + 1) / 2;
			return TPair<FName, FName>(*FString::Printf(TEXT("Key %d"), KeyIndex), *FString::Printf(TEXT("Value %d"), ValueIndex));
		};

		UK2Node_MakeMap* MakeMapNode = CompilerContext.SpawnIntermediateNode<UK2Node_MakeMap>(this, SourceGraph);
		MakeMapNode->NumInputs = 0;
		MakeMapNode->AllocateDefaultPins();

		UEdGraphPin* const MapOut = MakeMapNode->GetOutputPin();

		// Connect the output of the "Make Map" pin to the function's "Properties" pin
		MapOut->MakeLinkTo(GenerateThumbnailFunctionNode->FindPinChecked(FunctionPropertiesInputName));
		// This will set the "Make Map" node's type, only works if one pin is connected.
		MakeMapNode->PinConnectionListChanged(MapOut); 

		int32 ArgIdx = 0;
		// Create 'export property text' nodes and hook them up
		for (int32 PinIdx = 0; PinIdx < Pins.Num(); PinIdx++)
		{
			UEdGraphPin* Pin = Pins[PinIdx];
			if (!CheckIsValidSpawnVarPin(Pin))
				continue;

			MakeMapNode->AddInputPin();

			const auto PinNames        = GetMakeMapIndexNames(ArgIdx);
			UEdGraphPin* KeyInputPin   = MakeMapNode->FindPinChecked(PinNames.Key);
			UEdGraphPin* ValueInputPin = MakeMapNode->FindPinChecked(PinNames.Value);

			KeyInputPin->DefaultValue = Pin->PinName.ToString();

			// If the pin is connected, export the value of the connected property using ExportTextFunctionNode
			if (Pin->LinkedTo.Num() > 0)
			{
				const FName ExportTextFunctionName = SelectPropertyExportTextFunction(Pin);
				UK2Node_CallFunction* const ExportTextFunctionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
				ExportTextFunctionNode->FunctionReference.SetExternalMember(ExportTextFunctionName, UThumbnailGeneration::StaticClass());
				ExportTextFunctionNode->AllocateDefaultPins();

				UEdGraphPin* PropertyInputPin       = ExportTextFunctionNode->FindPinChecked(PropertyExporterPropertyInputName);
				UEdGraphPin* PropertyValueOutputPin = ExportTextFunctionNode->FindPinChecked(PropertyExporterReturnValueName);

				// Connect Property input
				bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*Pin, *PropertyInputPin).CanSafeConnect();
				ExportTextFunctionNode->PinConnectionListChanged(PropertyInputPin);
				
				PropertyValueOutputPin->MakeLinkTo(ValueInputPin);
			}
			else
			{
				ValueInputPin->DefaultValue = Pin->GetDefaultAsString();
			}

			ArgIdx++;
		}
	}

	if (!bIsErrorFree)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("InternalConnectionError", "UK2Node_GenerateThumbnail: Internal connection error. @@").ToString(), this);
	}

	BreakAllNodeLinks();
}

bool UK2Node_GenerateThumbnail::HasExternalDependencies(TArray<class UStruct*>* OptionalOutput) const
{
	const UBlueprint* SourceBlueprint = GetBlueprint();

	UClass* SourceClass = GetClassToSpawn();
	const bool bClassResult = (SourceClass && (SourceClass->ClassGeneratedBy != SourceBlueprint));
	if (bClassResult && OptionalOutput)
	{
		OptionalOutput->AddUnique(SourceClass);
	}

	const bool bThumbnailGeneratorClassResult = UThumbnailGenerator::StaticClass()->ClassGeneratedBy != SourceBlueprint;
	if (bThumbnailGeneratorClassResult && OptionalOutput)
	{
		OptionalOutput->AddUnique(UThumbnailGenerator::StaticClass());
	}

	const bool bSuperResult = Super::HasExternalDependencies(OptionalOutput);

	return bSuperResult || bClassResult || bThumbnailGeneratorClassResult;
}

void UK2Node_GenerateThumbnail::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	if (ActionRegistrar.IsOpenForRegistration(GetClass()))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(GetClass(), NodeSpawner);
	}
}

FText UK2Node_GenerateThumbnail::GetMenuCategory() const
{
	return FText::FromString("Thumbnail Generation");
}

FName UK2Node_GenerateThumbnail::GetCornerIcon() const
{
	return TEXT("Graph.Latent.LatentIcon");
}

void UK2Node_GenerateThumbnail::CreatePinsForClass(UClass* InClass, TArray<UEdGraphPin*>* OutClassPins)
{
	check(InClass);

	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	const UObject* const ClassDefaultObject = InClass->GetDefaultObject(false);

	for (TFieldIterator<FProperty> PropertyIt(InClass, EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt)
	{
		FProperty* Property = *PropertyIt;
		const bool bIsDelegate = Property->IsA(FMulticastDelegateProperty::StaticClass());
		const bool bIsExposedToSpawn = UEdGraphSchema_K2::IsPropertyExposedOnSpawn(Property);
		const bool bIsSettableExternally = !Property->HasAnyPropertyFlags(CPF_DisableEditOnInstance);

		if(	bIsExposedToSpawn &&
			!Property->HasAnyPropertyFlags(CPF_Parm) && 
			bIsSettableExternally &&
			Property->HasAllPropertyFlags(CPF_BlueprintVisible) &&
			!bIsDelegate &&
			(nullptr == FindPin(Property->GetFName()) ) &&
			FBlueprintEditorUtils::PropertyStillExists(Property))
		{
			if (UEdGraphPin* Pin = CreatePin(EGPD_Input, NAME_None, Property->GetFName()))
			{
				K2Schema->ConvertPropertyToPinType(Property, /*out*/ Pin->PinType);
				if (OutClassPins)
				{
					OutClassPins->Add(Pin);
				}

				if (ClassDefaultObject && K2Schema->PinDefaultValueIsEditable(*Pin))
				{
					FString DefaultValueAsString;
					const bool bDefaultValueSet = FBlueprintEditorUtils::PropertyValueToString(Property, reinterpret_cast<const uint8*>(ClassDefaultObject), DefaultValueAsString, this);
					check(bDefaultValueSet);
					K2Schema->SetPinAutogeneratedDefaultValue(Pin, DefaultValueAsString);
				}

				// Copy tooltip from the property.
				K2Schema->ConstructBasicPinTooltip(*Pin, Property->GetToolTipText(), Pin->PinToolTip);
			}
		}
	}

	// Change class of output pin
	UEdGraphPin* ResultPin = GetPreCaptureActorOutputPin();
	ResultPin->PinType.PinSubCategoryObject = InClass->GetAuthoritativeClass();
}

UClass* UK2Node_GenerateThumbnail::GetClassToSpawn(const TArray<UEdGraphPin*>* InPinsToSearch) const
{
	UClass* OutSpawnClass = nullptr;
	const TArray<UEdGraphPin*>* PinsToSearch = InPinsToSearch ? InPinsToSearch : &Pins;

	UEdGraphPin* ClassPin = GetClassPin(PinsToSearch);
	if (ClassPin && ClassPin->DefaultObject && ClassPin->LinkedTo.Num() == 0)
	{
		OutSpawnClass = CastChecked<UClass>(ClassPin->DefaultObject);
	}
	else if (ClassPin && ClassPin->LinkedTo.Num())
	{
		UEdGraphPin* ClassSource = ClassPin->LinkedTo[0];
		OutSpawnClass = ClassSource ? Cast<UClass>(ClassSource->PinType.PinSubCategoryObject.Get()) : nullptr;
	}

	return OutSpawnClass;
}

UEdGraphPin* UK2Node_GenerateThumbnail::GetClassPin(const TArray<UEdGraphPin*>* InPinsToSearch) const
{
	const TArray<UEdGraphPin*>* PinsToSearch = InPinsToSearch ? InPinsToSearch : &Pins;

	UEdGraphPin* Pin = nullptr;
	for (UEdGraphPin* TestPin : *PinsToSearch)
	{
		if (TestPin && TestPin->PinName == ClassPinName)
		{
			Pin = TestPin;
			break;
		}
	}
	check(Pin == nullptr || Pin->Direction == EGPD_Input);
	return Pin;
}

UEdGraphPin* UK2Node_GenerateThumbnail::GetThumbnailSettingsPin() const
{
	UEdGraphPin* Pin = FindPinChecked(ThumbnailSettingsPinName);
	check(Pin->Direction == EGPD_Input);
	return Pin;
}

UEdGraphPin* UK2Node_GenerateThumbnail::GetCacheMethodPin() const
{
	UEdGraphPin* Pin = FindPinChecked(CacheMethodPinName);
	check(Pin->Direction == EGPD_Input);
	return Pin;
}

UEdGraphPin* UK2Node_GenerateThumbnail::GetThenPin() const
{
	UEdGraphPin* Pin = FindPin(UEdGraphSchema_K2::PN_Then);
	check(Pin == nullptr || Pin->Direction == EGPD_Output); // If pin exists, it must be output
	return Pin;
}

UEdGraphPin* UK2Node_GenerateThumbnail::GetPreCaptureActorOutputPin() const
{
	UEdGraphPin* Pin = FindPin(PreCaptureActorOutputPinName);
	check(Pin == nullptr || Pin->Direction == EGPD_Output); // If pin exists, it must be output
	return Pin;
}

void UK2Node_GenerateThumbnail::SetPinToolTip(UEdGraphPin& MutatablePin, const FText& PinDescription) const
{
	MutatablePin.PinToolTip = UEdGraphSchema_K2::TypeToText(MutatablePin.PinType).ToString();

	UEdGraphSchema_K2 const* const K2Schema = Cast<const UEdGraphSchema_K2>(GetSchema());
	if (K2Schema != nullptr)
	{
		MutatablePin.PinToolTip += TEXT(" ");
		MutatablePin.PinToolTip += K2Schema->GetPinDisplayName(&MutatablePin).ToString();
	}

	MutatablePin.PinToolTip += FString(TEXT("\n")) + PinDescription.ToString();
}

bool UK2Node_GenerateThumbnail::IsSpawnVarPin(UEdGraphPin* Pin) const
{
	return Pin->PinName != UEdGraphSchema_K2::PN_Execute &&
		   Pin->PinName != UEdGraphSchema_K2::PN_Then &&
		   Pin->PinName != UEdGraphSchema_K2::PN_ReturnValue &&
		   Pin->PinName != ClassPinName &&
		   Pin->PinName != ThumbnailSettingsPinName &&
		   Pin->PinName != CacheMethodPinName &&
		   Pin->PinName != CallbackPinName &&
		   Pin->PinName != ThumbnailOutputPinName &&
		   Pin->PinName != PreCapturePinName &&
		   Pin->PinName != PreCapturePinName &&
		   Pin->PinName != PreCaptureActorOutputPinName;
}

void UK2Node_GenerateThumbnail::OnClassPinChanged()
{
	// Remove all pins related to archetype variables
	TArray<UEdGraphPin*> OldPins = Pins;
	TArray<UEdGraphPin*> OldClassPins;

	for (UEdGraphPin* OldPin : OldPins)
	{
		if (IsSpawnVarPin(OldPin))
		{
			Pins.Remove(OldPin);
			OldClassPins.Add(OldPin);
		}
	}

	CachedNodeTitle.MarkDirty();

	TArray<UEdGraphPin*> NewClassPins;
	if (UClass* UseSpawnClass = GetClassToSpawn())
	{
		CreatePinsForClass(UseSpawnClass, &NewClassPins);
	}

	RestoreSplitPins(OldPins);

	UEdGraphPin* ResultPin = GetPreCaptureActorOutputPin();
	// Cache all the pin connections to the ResultPin, we will attempt to recreate them
	TArray<UEdGraphPin*> ResultPinConnectionList = ResultPin->LinkedTo;
	// Because the archetype has changed, we break the output link as the output pin type will change
	ResultPin->BreakAllPinLinks(true);

	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	// Recreate any pin links to the Result pin that are still valid
	for (UEdGraphPin* Connections : ResultPinConnectionList)
	{
		K2Schema->TryCreateConnection(ResultPin, Connections);
	}

	// Rewire the old pins to the new pins so connections are maintained if possible
	RewireOldPinsToNewPins(OldClassPins, Pins, nullptr);

	// Refresh the UI for the graph so the pin changes show up
	GetGraph()->NotifyGraphChanged();

	// Mark dirty
	FBlueprintEditorUtils::MarkBlueprintAsModified(GetBlueprint());
}

#undef LOCTEXT_NAMESPACE